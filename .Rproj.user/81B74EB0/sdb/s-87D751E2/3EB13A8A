{
    "contents" : "#' Extract educational background of Williams College faculty\n#'\n#' \\code{extract_info} creates a data frame by parsing and giving tabular structure to a\n#'  text file that contains raw data. It uses three other functions that are also from this\n#'  package: \\code{\\link{scrub}}, \\code{\\link{gather_reformatted}}/\\code{\\link{gather_exactly}} and \\code{\\link{fill_gaps}}.\n#'\n#' @param year an academic year of which faculty information is desired.\n#' @param source_year an optional academic year that contains desired data. If the catalog of\n#' the desired academic year already contains the data, then repeat the first year.\n#' @param transformNames logical. If FALSE (the default) names are scraped exactly they\n#' appear on the document, otherwise the first and last names are reordered.\n#' @param fillGaps logical. If TRUE (the default) missing data is extracted from Williams'\n#' website, otherwise it is left blank.\n#' @return The output is a data frame that contains the name, graduation year, degree,\n#' college and current age of faculty members.\n#' @section Note:\n#' Assigning the TRUE value to \\code{fillGaps} may result in a code execution that takes a\n#' while to finish. If needed, this step can be done separately with the\n#' \\code{\\link{fill_gaps}} function that takes and returns a data frame.\n#' @examples\n#' extract_info(\"2015-16\", \"2013-14\", transformNames = TRUE, fillGaps = TRUE)\n#' extract_info(\"2013-14\", \"2013-14\", fillGaps = FALSE)\n#' extract_info(\"2014-15\", \"2013-14\", fillGaps = FALSE)\nextract_info <- function(year, source_year,\n                transformNames = FALSE, fillGaps = TRUE){\n  data <- scrub(year)\n  if (!missing(source_year)){\n    data2 <- scrub(source_year)\n  }\n  if (transformNames == TRUE){\n    names <- gather_reformatted(data)\n  }else{\n    names <- gather_exactly(data)\n  }\n  faculty_df <- data.frame(matrix(vector(), length(names), 5,\n    dimnames=list(c(), c(\"Name\", \"Graduation.Year\", \"Degree\", \"College\", \"Current.Age\"))),\n    stringsAsFactors=FALSE)\n  for (i in seq(along = names)){\n    if (length(grep(names[i], data2))==0){\n      faculty_df[i, ] <- c(names[i], rep(NA, 4))\n    }else{\n      pattern <- \"\\\\d{4}, (B\\\\w+|AB), (.*?),\"\n      education_info <- regmatches(data2[grep(names[i], data2)], regexpr(pattern, data2[grep(names[i], data2)]))\n      if (length(education_info) == 0){\n        faculty_df[i, ] <- c(names[i], rep(NA, 4))\n      }else{\n        year <- gsub(\",(.*)\", \"\", education_info)\n        degree <- gsub(\"\\\\d{4}, |,(.*)\", \"\", education_info)\n        college <- gsub(\"\\\\d{4}(.*), |,\", \"\", education_info)\n        faculty_df[i, ] <- c(names[i], year, degree, college, 2016-as.integer(year)+22)\n      }\n    }\n  }\n  by1 <- c(\"BA\", \"BS\", \"BM\", \"BFA\", \"BPhil\", \"AB\", \"BE\")\n  by2 <- c(\"B.A.\", \"B.S.\", \"B.M.\", \"B.F.A.\", \"B.Phil.\", \"B.A.\", \"B.E.\")\n  for (j in 1:7){\n    faculty_df$Degree <- sub(by1[j], by2[j], faculty_df$Degree)\n  }\n\n  if (fillGaps == TRUE){\n    # The carrot makes sure that we only get the first word of each names element.\n    first_name <- regmatches(names, regexpr(\"^\\\\w+\", names))\n\n    # The optional \\\\w+[-] pattern makes sure that we take hypenated last names such as\n    # 'Robert Baker-White' into account.\n    last_name <- regmatches(names, regexpr(\"(\\\\w+[-])?\\\\w+$\", names))\n\n    search_query <- paste(first_name, \"+\", last_name, sep = \"\")\n    search_link <- paste(\"http://www.williams.edu/people/?s_directory=\", search_query, sep = \"\")\n    # Only deal with the ones with a missing value\n    for (i in which(is.na(faculty_df[ ,2]) == TRUE)){\n      tryCatch({\n      directory_search <- read_html(search_link[i])\n      }, error=function(e){cat(\"Unidentified error in the first connection during\", print(i), \"\\n\")})\n      email_node <- html_nodes(directory_search, css = \".phone+ .email a\")\n      if (length(email_node) != 0){\n        unix_id <- gsub(\"mailto:|@williams.edu\", \"\", html_attr(email_node, \"href\"))\n        if (length(unix_id) > 1){\n          print(cat(\"Warning: More than one people with the name\", print(names[i]), \"\\n\"))\n        }\n        tryCatch({\n        profile_data <- html_text(\n                        html_nodes(\n                        read_html(\n                        paste(\"http://www.williams.edu/profile/\", unix_id[1], sep=\"\")),\n                        css = \".profile-education .profile-subsection\"))\n        }, error=function(e){cat(\"Unidentified error in the second connection during\", print(i), \"\\n\")})\n        pattern <- \"(B\\\\.(.*?)\\\\.|A\\\\.B\\\\.|Diploma) .*? \\\\(\\\\d{4}\\\\)\"\n\n        # Catch potential exceptions\n        tryCatch({\n          education_info <- regmatches(profile_data, regexpr(pattern, profile_data))\n          year <- as.integer(\n            gsub(\"(B\\\\.(.*?)\\\\.|A\\\\.B\\\\.|Diploma) .* \\\\(|\\\\)\", \"\", education_info))\n          degree <- gsub(\" .*\", \"\", education_info)\n          college <- gsub(\"(B\\\\.(.*?)\\\\.|A\\\\.B\\\\.|Diploma) | \\\\(\\\\d{4}\\\\)\", \"\", education_info)\n          faculty_df[i,2:5] <- c(year, degree, college, 2016-as.integer(year)+22)\n        }, error=function(e){cat(\"Missing information on\", print(names[i]), \"\\n\")})\n      }\n    }\n  }\n  faculty_df$Degree <- as.factor(faculty_df$Degree)\n  faculty_df$Graduation.Year <- as.integer(faculty_df$Graduation.Year)\n  faculty_df$Current.Age <- as.factor(faculty_df$Current.Age)\n  return(faculty_df)\n}",
    "created" : 1454386743025.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3046396952",
    "id" : "3EB13A8A",
    "lastKnownWriteTime" : 1454482925,
    "path" : "C:/Users/Zafer/Desktop/R Project/packages/ager/R/extract_info.R",
    "project_path" : "R/extract_info.R",
    "properties" : {
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "type" : "r_source"
}