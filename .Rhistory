flat_file <- scrub_catalog("2014-15")
data_source <- scrub_catalog("2013-14")
names <- collect_names(flat_file, reformat = FALSE)
academic_data <- extract_data(names, data_source, useInternet = TRUE)
dput(academic_data, file = "./inst/extdata/academic_data1415.txt", control = "showAttributes")
faculty1415_df <- transform_data(academic_data)
write.csv(faculty1415_df, file = "./inst/extdata/faculty1415_df.csv", row.names = FALSE)
academic_data[1]
academic_data[4]
academic_data[5]
academic_data[3]
sub("(\\d{4}).*", "\\1", selected_data)
sub("(\\d{4}).*", "\\1", academic_data[3])
years <- as.numeric(sub(".*(\\d{4}).*", "\\1", selected_data))
sub(".*(\\d{4}).*", "\\1", academic_data[3])
sub(".*(\\d{4}).*", "\\1", academic_data[1])
sub(".*(\\d{4}).*", "\\1", academic_data[2])
sub(".*(\\d{4}).*", "\\1", academic_data[3])
sub(".*(\\d{4}).*", "\\1", academic_data[4])
sub(".*(\\d{4}).*", "\\1", academic_data[5])
sub(".*(B\\.(.*?)\\.|A\\.B\\.|Diploma).*", "\\1", selected_data)
sub(".*(B\\.(.*?)\\.|A\\.B\\.|Diploma).*", "\\1", academic_data[1])
by1 <- c("BA", "BS", "BM", "BFA", "BPhil", "AB", "BE", "A.B.")
by2 <- c("B.A.", "B.S.", "B.M.", "B.F.A.", "B.Phil.", "B.A.", "B.E.", "B.A.")
for(j in 1:8){
academic_data <- sub(by1[j], by2[j], academic_data)
}
sub(".*(B\\.(.*?)\\.|A\\.B\\.|Diploma).*", "\\1", academic_data[1])
sub(".*(B\\.(.*?)\\.|A\\.B\\.|Diploma).*", "\\1", academic_data[2])
sub(".*(B\\.(.*?)\\.|A\\.B\\.|Diploma).*", "\\1", academic_data[3])
sub(".*(B\\.(.*?)\\.|A\\.B\\.|Diploma).*", "\\1", academic_data[4])
sub(".*(B\\.(.*?)\\.|A\\.B\\.|Diploma).*", "\\1", academic_data[5])
transform_data <- function(selected_data){
by1 <- c("BA", "BS", "BM", "BFA", "BPhil", "AB", "BE", "A.B.")
by2 <- c("B.A.", "B.S.", "B.M.", "B.F.A.", "B.Phil.", "B.A.", "B.E.", "B.A.")
for (j in 1:8){
selected_data <- sub(by1[j], by2[j], selected_data)
}
years <- as.numeric(sub(".*(\\d{4}).*", "\\1", selected_data))
degrees <- as.factor(sub(".*(B\\.(.*?)\\.|A\\.B\\.|Diploma).*", "\\1", selected_data))
data_frame <- data.frame(Names = names(selected_data),
Graduation.Year = years,
Degree = degrees,
Age = (2016 + 22 - years),
stringsAsFactors = FALSE,
row.names = NULL
)
return(data_frame)
}
faculty1415_df <- transform_data(academic_data)
write.csv(faculty1415_df, file = "./inst/extdata/faculty1415_df.csv", row.names = FALSE)
write.csv(faculty1415_df, file = "./inst/extdata/faculty1415_df.csv", row.names = FALSE)
flat_file <- scrub_catalog("2015-16")
data_source <- scrub_catalog("2013-14")
names <- collect_names(flat_file, reformat = TRUE)
academic_data <- dget(file = "./inst/extdata/academic_data1516.txt")
academic_data <- dget(file = "./inst/extdata/academic_data1516.txt")
faculty1516_df <- transform_data(academic_data)
write.csv(faculty1516_df, file = "./inst/extdata/faculty1516_df.csv", row.names = FALSE)
head(faculty1516_df)
unique(faculty1516_df)
unique(faculty1516_df$Degree)
devtools::load_all()
devtools::load_all()
#' Clean catalog files
#'
#' \code{scrub_catalog} removes all irrelevant data in catalog files.
#'
#' @param year an academic year of which faculty information is desired.
#' @return The output is a character vector. Each element of this vector is a character
#' string that contains information on a faculty member.
#' @examples
#' scrub_catalog("2011-12")
scrub_catalog <- function(year){
# Open up a txt file and store lines of information as character strings of the
# vector 'data'
flat_file <- paste(year, ".txt", sep = "") %>%
system.file("extdata", ., package = "ager") %>%
readLines(skipNul = TRUE)
# Remove leftovers from the previous page. In this case, we do not have any, however
# there are, for instance in the catalog from the year 2010-2011, some.
flat_file <- flat_file[-(1:(grep("FACULTY", flat_file)[1]))]
# Remove all other irrelevant data at the beginning of the document until coming
# across a line containing a comma
flat_file <- flat_file[-(1:(grep(",", flat_file)[1] - 1))]
# Remove the strings which are of length 0 and those containing page numbers. 4 is not
# chosen arbitrarily but rather based on other years' documents. For instance in the
# previous 2 years, the strings that contain pages are formatted as 3-digit integer and
# a space.
flat_file <- setdiff(flat_file, flat_file[nchar(flat_file) <= 4])
if (year == "2013-14"){
# Clean up text if it is formatted with hard line endings
short_lines <- order(nchar(flat_file), decreasing=FALSE)[1:15]
long_lines <- order(nchar(flat_file), decreasing=TRUE)[1:15]
# Evaluate which of the long lines are immediately followed by a short line
cut_lines <- short_lines[(short_lines - 1) %in% long_lines]
# Join the cut off line with the line above
flat_file[cut_lines - 1] <- paste(flat_file[cut_lines - 1], flat_file[cut_lines], sep=" ")
# Remove cut off lines
flat_file <- setdiff(flat_file, flat_file[cut_lines])
}
return(flat_file)
}
flat_file <- scrub_catalog("2015-16")
library(magrittr)
library(devtools)
devtools::load_all()
load_all()
#' Collect names
#'
#' \code{collect_names} identifies names of faculty members from a selected document and
#' collects them
#'
#' @param flat_file a vector that contains character strings
#' @param reformat
#' @return The output is a character vector that contains the names of faculty members as
#' they exactly appear on the data source but without any special characters at the
#' beginning of strings.
#' @examples
#' scrub("2010-11") %>% collect_names()
collect_names <- function(flat_file, reformat = FALSE){
if (reformat == FALSE){
names <-
"[A-Z](.*?)," %>%
regexpr(flat_file) %>%
regmatches(flat_file, .) %>%
gsub(",", "", .)
}
else if (reformat == TRUE){
# Obtain first names using regular expressions
first_names <-
",(| )(.*?)," %>%
regexpr(flat_file) %>%
regmatches(flat_file, .) %>%
gsub(",(| )|,", "", .)
# Similarly,
last_names <-
"[A-Z](.*?)," %>%
regexpr(flat_file) %>%
regmatches(flat_file, .) %>%
gsub(",.*", "", .)
names <- paste(first_names, last_names, sep = " ")
}
return(names)
}
load_all()
library(ager)
library(knitr)
library(foxygen2)
library(roxygen2)
install.packages(backtest)
install.packages("backtest")
use_package(magrittr)
use_package("magrittr")
use_package("devtools")
use_package("reshape2")
use_package("rmarkdown")
use_package("testthat")
use_package("rvest")
use_package("dplyr")
use_package("knitr")
load_all()
devtools::load_all
devtools::load_all()
devtools::has_dev()
document()
#' Extract academic data
#'
#' \code{extract_data} extracts the data that contains academic background of faculty
#' members from (1) a catalog chosen as the data source and (2) Williams' web directory.
#'
#' @param names character vector that contains the names of faculty members whose academic
#' information is desired.
#' @param data_source a plain text file that contains the desired information.
#' @param useInternet logical. If TRUE missing data is extracted from Williams' website,
#' otherwise it is left blank.
#' @return The output is a named vector that contains the graduation year and the degree of
#' faculty members.
#' @section Note:
#' Assigning the TRUE value to \code{useInternet} may result in a code execution that takes a
#' while to finish.
#' @examples
#' flat_file <- scrub_catalog("2015-16")
#' + names <- collect_names(flat_file, reformat = TRUE)
#' + data_source <- scrub_catalog("2013-14")
#' + extract_data(names, data_source, useInternet = TRUE)
extract_data <- function(names, data_source, useInternet = FALSE){
pattern <- "\\d{4}, (B\\w+|AB), (.*?),"
academic_data <- sapply(names, function(x){
vector <-
regexpr(pattern, data_source[grep(x, data_source)]) %>%
regmatches(data_source[grep(x, data_source)], .)
if(length(vector) == 0){
return(NA)
}else{
return(vector)
}
})
# The carrot makes sure that we only get the first word of each names element.
first_name <- regmatches(names, regexpr("^\\w+", names))
# The optional \\w+[-] pattern makes sure that we take hypenated last names such as
# 'Robert Baker-White' into account.
last_name <- regmatches(names, regexpr("(\\w+[-])?\\w+$", names))
# Generate search queries in order to access data on the web directory
search_query <- paste(first_name, "+", last_name, sep = "")
search_link <- paste("http://www.williams.edu/people/?s_directory=",
search_query,
sep = "")
# Return the indices of the elements with missing data
missing_data <- unname(which(is.na(academic_data == TRUE)))
if (useInternet == TRUE){
for (i in missing_data){
tryCatch({
directory_search <- read_html(search_link[i])
}, error=function(e){cat("Unidentified error in the first connection during", print(i), "\n")})
email_node <- html_nodes(directory_search, css = ".phone+ .email a")
if (length(email_node) != 0){
unix_id <- gsub("mailto:|@williams.edu", "", html_attr(email_node, "href"))
if (length(unix_id) > 1){
print(cat("Warning: More than one people with the name", print(names[i]), "\n"))
}
tryCatch({
profile_data <- html_text(
html_nodes(
read_html(
paste("http://www.williams.edu/profile/", unix_id[1], sep="")),
css = ".profile-education .profile-subsection"))
}, error=function(e){cat("Unidentified error in the second connection during", print(i), "\n")})
pattern <- "(B\\.(.*?)\\.|A\\.B\\.|Diploma) .*? \\(\\d{4}\\)"
# Catch potential exceptions
tryCatch({
academic_data[i] <- regmatches(profile_data, regexpr(pattern, profile_data))
}, error=function(e){cat("Missing information on", print(names[i]), "\n")})
}
}
}
return(academic_data)
}
document()
document()
?read.table
#' Transform data
#'
#' \code{transform_data} converts extracted data into a structured data frame
#'
#' @param selected_data a named vector that contains the graduation year and the degree of
#' faculty members..
#' @return The output is a data frame which consists of all relevant data.
#' @examples
#' academic_year <- "2015-16"
#' + flat_file <- scrub_catalog(academic_year)
#' + names <- collect_names(flat_file, reformat = TRUE)
#' + data_source <- scrub_catalog("2013-14")
#' + academic_data <- extract_data(names, data_source, useInternet = TRUE)
#' + data_frame <- transform_data(academic_data)
transform_data <- function(selected_data){
by1 <- c("BA", "BS", "BM", "BFA", "BPhil", "AB", "BE", "A.B.")
by2 <- c("B.A.", "B.S.", "B.M.", "B.F.A.", "B.Phil.", "B.A.", "B.E.", "B.A.")
for (j in 1:8){
selected_data <- sub(by1[j], by2[j], selected_data)
}
grad_years <- as.numeric(sub(".*(\\d{4}).*", "\\1", selected_data))
degrees <- as.factor(sub(".*(B\\.(.*?)\\.|A\\.B\\.|Diploma).*", "\\1", selected_data))
data_frame <- data.frame(Name = names(selected_data),
Graduation.Year = grad_years,
Degree = degrees,
Age = (2016 + 22 - grad_years),
Academic.Year = academic_year,
stringsAsFactors = FALSE,
row.names = NULL
)
return(data_frame)
}
#' Extract academic data
#'
#' \code{extract_data} extracts the data that contains academic background of faculty
#' members from (1) a catalog chosen as the data source and (2) Williams' web directory.
#'
#' @param names character vector that contains the names of faculty members whose academic
#' information is desired.
#' @param data_source a plain text file that contains the desired information.
#' @param useInternet logical. If TRUE missing data is extracted from Williams' website,
#' otherwise it is left blank.
#' @return The output is a named vector that contains the graduation year and the degree of
#' faculty members.
#' @section Note:
#' Assigning the TRUE value to \code{useInternet} may result in a code execution that takes a
#' while to finish.
#' @examples
#' academic_year <- "2015-16"
#' + flat_file <- scrub_catalog(academic_year)
#' + names <- collect_names(flat_file, reformat = TRUE)
#' + data_source <- scrub_catalog("2013-14")
#' + academic_data <- extract_data(names, data_source, useInternet = TRUE)
extract_data <- function(names, data_source, useInternet = FALSE){
pattern <- "\\d{4}, (B\\w+|AB), (.*?),"
academic_data <- sapply(names, function(x){
vector <-
regexpr(pattern, data_source[grep(x, data_source)]) %>%
regmatches(data_source[grep(x, data_source)], .)
if(length(vector) == 0){
return(NA)
}else{
return(vector)
}
})
# The carrot makes sure that we only get the first word of each names element.
first_name <- regmatches(names, regexpr("^\\w+", names))
# The optional \\w+[-] pattern makes sure that we take hypenated last names such as
# 'Robert Baker-White' into account.
last_name <- regmatches(names, regexpr("(\\w+[-])?\\w+$", names))
# Generate search queries in order to access data on the web directory
search_query <- paste(first_name, "+", last_name, sep = "")
search_link <- paste("http://www.williams.edu/people/?s_directory=",
search_query,
sep = "")
# Return the indices of the elements with missing data
missing_data <- unname(which(is.na(academic_data == TRUE)))
if (useInternet == TRUE){
for (i in missing_data){
tryCatch({
directory_search <- read_html(search_link[i])
}, error=function(e){cat("Unidentified error in the first connection during", print(i), "\n")})
email_node <- html_nodes(directory_search, css = ".phone+ .email a")
if (length(email_node) != 0){
unix_id <- gsub("mailto:|@williams.edu", "", html_attr(email_node, "href"))
if (length(unix_id) > 1){
print(cat("Warning: More than one people with the name", print(names[i]), "\n"))
}
tryCatch({
profile_data <- html_text(
html_nodes(
read_html(
paste("http://www.williams.edu/profile/", unix_id[1], sep="")),
css = ".profile-education .profile-subsection"))
}, error=function(e){cat("Unidentified error in the second connection during", print(i), "\n")})
pattern <- "(B\\.(.*?)\\.|A\\.B\\.|Diploma) .*? \\(\\d{4}\\)"
# Catch potential exceptions
tryCatch({
academic_data[i] <- regmatches(profile_data, regexpr(pattern, profile_data))
}, error=function(e){cat("Missing information on", print(names[i]), "\n")})
}
}
}
return(academic_data)
}
#' Load data
#'
#' \code{load_data} creates a cumulative data frame which includes data from various
#' academic years.
#'
#' @param df1 a data frame
#' @param df2 a data frame
#' @param df3 a data frame
#' @param ... further data frames to be passed to \code{load_data}
#' @return The output is a data frame.
#' @examples
#' data_warehouse_df <- load_data(faculty1516_df, faculty1415_df)
load_data <- function(df1, df2, df3, ...){
data_warehouse_df <- rbind(df1, df2, df3, ...) %>%
mutate(Age.Group = cut(Age, breaks = seq(20, 80, by = 10)))
return(data_warehouse_df)
}
#' Clean catalog files
#'
#' \code{scrub_catalog} removes all irrelevant data in catalog files.
#'
#' @param year an academic year of which faculty data is desired.
#' @return The output is a character vector that contains one record per element.
#' @examples
#' scrub_catalog("2011-12")
scrub_catalog <- function(year){
# Open up a txt file and store lines of information as character strings of the
# vector 'data'
flat_file <- paste(year, ".txt", sep = "") %>%
system.file("extdata", ., package = "ager") %>%
readLines(skipNul = TRUE)
# Remove leftovers from the previous page. In this case, we do not have any, however
# there are, for instance in the catalog from the year 2010-2011, some.
flat_file <- flat_file[-(1:(grep("FACULTY", flat_file)[1]))]
# Remove all other irrelevant data at the beginning of the document until coming
# across a line containing a comma
flat_file <- flat_file[-(1:(grep(",", flat_file)[1] - 1))]
# Remove the strings which are of length 0 and those containing page numbers. 4 is not
# chosen arbitrarily but rather based on other years' documents. For instance in the
# previous 2 years, the strings that contain pages are formatted as 3-digit integer and
# a space.
flat_file <- setdiff(flat_file, flat_file[nchar(flat_file) <= 4])
if (year == "2013-14"){
# Clean up text if it is formatted with hard line endings
short_lines <- order(nchar(flat_file), decreasing=FALSE)[1:15]
long_lines <- order(nchar(flat_file), decreasing=TRUE)[1:15]
# Evaluate which of the long lines are immediately followed by a short line
cut_lines <- short_lines[(short_lines - 1) %in% long_lines]
# Join the cut off line with the line above
flat_file[cut_lines - 1] <- paste(flat_file[cut_lines - 1], flat_file[cut_lines], sep=" ")
# Remove cut off lines
flat_file <- setdiff(flat_file, flat_file[cut_lines])
}
return(flat_file)
}
#' Collect names
#'
#' \code{collect_names} identifies names of faculty members from a selected document and
#' collects them
#'
#' @param flat_file a plain text file that contains one record (i.e., faculty member)
#' per line.
#' @param reformat logical. If FALSE (the default) names are collected exactly they
#' appear on the document, otherwise the first and last names are reordered.
#' @return The output is a character vector that contains the names of faculty members
#' without any special characters indicating whether the faculty member is visiting or on
#' leave.
#' @examples
#' names <- scrub_catalog("2013-14") %>% collect_names(reformat = FALSE)
#' names <- scrub_catalog("2015-16") %>% collect_names(reformat = TRUE)
collect_names <- function(flat_file, reformat = FALSE){
if (reformat == FALSE){
names <-
"[A-Z](.*?)," %>%
regexpr(flat_file) %>%
regmatches(flat_file, .) %>%
gsub(",", "", .)
}
else if (reformat == TRUE){
# Obtain first names using regular expressions
first_names <-
",(| )(.*?)," %>%
regexpr(flat_file) %>%
regmatches(flat_file, .) %>%
gsub(",(| )|,", "", .)
# Similarly,
last_names <-
"[A-Z](.*?)," %>%
regexpr(flat_file) %>%
regmatches(flat_file, .) %>%
gsub(",.*", "", .)
names <- paste(first_names, last_names, sep = " ")
}
return(names)
}
academic_year <- "2015-16"
+ flat_file <- scrub_catalog(academic_year)
+ names <- collect_names(flat_file, reformat = TRUE)
+ data_source <- scrub_catalog("2013-14")
+ academic_data <- dget(file = "./inst/extdata/academic_data1516.txt")
+ faculty1516_df <- transform_data(academic_data)
academic_year <- "2015-16" +
flat_file <- scrub_catalog(academic_year)
academic_year <- "2015-16"
flat_file <- scrub_catalog(academic_year)
names <- collect_names(flat_file, reformat = TRUE)
data_source <- scrub_catalog("2013-14")
academic_data <- dget(file = "./inst/extdata/academic_data1516.txt")
faculty1516_df <- transform_data(academic_data)
head(faculty1516_df)
academic_year <- "2013-14"
flat_file <- scrub_catalog(academic_year)
data_source <- scrub_catalog("2013-14")
names <- collect_names(flat_file, reformat = FALSE)
academic_data <- extract_data(names, data_source, useInternet = FALSE)
faculty1314_df <- transform_data(academic_data)
head(faculty1314_df)
write.csv(faculty1314_df, file = "./inst/extdata/faculty1314_df.csv", row.names = FALSE)
academic_year <- "2014-15"
flat_file <- scrub_catalog(academic_year)
data_source <- scrub_catalog("2013-14")
names <- collect_names(flat_file, reformat = FALSE)
academic_data <- dget(file = "./inst/extdata/academic_data1415.txt")
faculty1415_df <- transform_data(academic_data)
write.csv(faculty1415_df, file = "./inst/extdata/faculty1415_df.csv", row.names = FALSE)
academic_year <- "2014-15"
flat_file <- scrub_catalog(academic_year)
data_source <- scrub_catalog("2013-14")
names <- collect_names(flat_file, reformat = FALSE)
academic_data <- dget(file = "./inst/extdata/academic_data1415.txt")
faculty1415_df <- transform_data(academic_data)
write.csv(faculty1415_df, file = "./inst/extdata/faculty1415_df.csv", row.names = FALSE)
academic_year <- "2015-16"
flat_file <- scrub_catalog(academic_year)
data_source <- scrub_catalog("2013-14")
names <- collect_names(flat_file, reformat = TRUE)
academic_data <- dget(file = "./inst/extdata/academic_data1516.txt")
faculty1516_df <- transform_data(academic_data)
write.csv(faculty1516_df, file = "./inst/extdata/faculty1516_df.csv", row.names = FALSE)
data_warehouse_df <- load_data(faculty1516_df, faculty1415_df)
#' Load data
#'
#' \code{load_data} creates a cumulative data frame which includes data from various
#' academic years.
#'
#' @param df1 a data frame
#' @param df2 a data frame
#' @param df3 a data frame
#' @param ... further data frames to be passed to \code{load_data}
#' @return The output is a data frame.
#' @examples
#' data_warehouse_df <- load_data(faculty1516_df, faculty1415_df)
load_data <- function(df1, df2, ...){
data_warehouse_df <- rbind(df1, df2, ...) %>%
mutate(Age.Group = cut(Age, breaks = seq(20, 80, by = 10)))
return(data_warehouse_df)
}
data_warehouse_df <- load_data(faculty1516_df, faculty1415_df)
head(data_warehouse)
head(data_warehouse_df)
str(data_warehouse_df)
data_warehouse_df <- load_data(faculty1516_df, faculty1415_df, faculty1314_df)
str(data_warehouse_df)
tail(data_warehouse_df)
document()
devtools::document()
